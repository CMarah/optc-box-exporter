<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>OpenCV.js</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb" crossorigin="anonymous">
    <style type="text/css">
      .modal {
        display:    none;
        position:   fixed;
        z-index:    1000;
        top:        0;
        left:       0;
        height:     100%;
        width:      100%;
        background: rgba( 255, 255, 255, .8 )
          url('http://i.stack.imgur.com/FhHRx.gif')
          50% 50%
          no-repeat;
      }
      body.loading {
        overflow: hidden;
      }
      body.loading .modal {
        display: block;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="jumbotron">
        <h1>OPTC Box Processor</h1>
        <p>This website uses OpenCVJS to detect your OPTC box contents.</p>
        <!--img id="compare" src="compare.png"/-->
        <img id="compare"/>
      </div>
      <div class="row">
        <div class="col-sm">
          <div class="card">
            <div class="card-header">
              Original Image
            </div>
            <div class="card-block text-center">
              <img id="imageOriginal" alt="Upload" class="card-img-top"/>
            </div>
            <div class="card-footer text-muted">
              <input type="file" id="imageInput" name="file" />
            </div>
          </div>
        </div>
        <div class="col-sm">
          <div class="card">
            <div class="card-header">
              Modified Image
            </div>
            <div class="card-block">
              <canvas id="imageCanvas"></canvas>
            </div>
            <button type="button" id="circlesButton" class="btn btn-primary">Detect</button>
            <div class="card-footer">
              <a href="#" id="button" class="card-link">Download Image</a>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="modal"></div>
    <script type="text/javascript">
      document.body.classList.add("loading");
      let imgElement = document.getElementById('imageOriginal');
      let inputElement = document.getElementById('imageInput');
      inputElement.addEventListener('change', (e) => {
        imgElement.src = URL.createObjectURL(e.target.files[0]);
      }, false);

      let a = document.getElementById("compare");
      a.crossOrigin = "*";
      a.src="images/c3.png"

      imgElement.onload = () => {
        const src = cv.imread(imgElement);
        let dst = new cv.Mat();
        const rect = new cv.Rect(0, src.rows/4, src.cols, src.rows/2);
        dst = src.roi(rect);
        cv.imshow('imageCanvas', dst);
        src.delete(); dst.delete();
      };

document.getElementById('circlesButton').onclick = function() {
  // Initialize variables
  this.disabled = true;
  let src = cv.imread('imageCanvas');
  let clean = src.clone();
  let itr = src.clone();
  let dst = src.clone();
  let hlines = new cv.Mat();
  let vlines = new cv.Mat();
  let bullet = cv.imread('compare');

  // Draw white squares around chars
  cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
  cv.Canny(src, src, 50, 200, 3);
  cv.HoughLines(src, hlines, 1, Math.PI/180, 260, 0, 0, 0, 0.01);
  cv.HoughLines(src, vlines, 1, Math.PI/180, 260, 0, 0, Math.PI/2, Math.PI/2+0.1);
  for (let i = 0; i < (hlines.rows + vlines.rows); ++i) {
    let rho = i < hlines.rows ?
      hlines.data32F[i * 2] :
      vlines.data32F[(i - hlines.rows) * 2];
    let theta = i < hlines.rows ?
      hlines.data32F[i * 2 + 1] :
      vlines.data32F[(i - hlines.rows) * 2 + 1];
    const a = Math.cos(theta);
    const b = Math.sin(theta);
    const x0 = a * rho;
    const y0 = b * rho;
    const startPoint = { x: x0 - 1000 * b, y: y0 + 1000 * a};
    const endPoint =   { x: x0 + 1000 * b, y: y0 - 1000 * a};
    cv.line(itr, startPoint, endPoint, [255, 255, 255, 255], 6);
  }

  // Find contour for each square
  cv.cvtColor(itr, itr, cv.COLOR_RGBA2GRAY, 0);
  const ksize = new cv.Size(3, 3);
  const anchor = new cv.Point(-1, -1);
  cv.blur(itr, itr, ksize, anchor, cv.BORDER_DEFAULT);
  cv.threshold(itr, itr, 250, 200, cv.THRESH_BINARY);
  let contours = new cv.MatVector();
  let hierarchy = new cv.Mat();
  cv.findContours(itr, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);

  let rects = [];
  for (let i = 0; i < contours.size(); ++i) {
    const rect = cv.boundingRect(contours.get(i));
    const area = rect.width*rect.height;
    if (area > 5000 && area < 10000) {
      rects.push(rect);
      /*const color = new cv.Scalar(
        Math.round(Math.random() * 255),
        Math.round(Math.random() * 255),
        Math.round(Math.random() * 255)
      );*/
      //console.log(rec2);
      //character_imgs.push(clean.roi(rec2));
      //cv.drawContours(dst, contours, i, color, 3, cv.LINE_8, hierarchy, 100);
    }
  }
  const avg_width  = rects.reduce((acc, r) => acc + r.width/rects.length, 0);
  const avg_height = rects.reduce((acc, r) => acc + r.height/rects.length, 0);
  console.log(avg_width, avg_height);
  const character_imgs = rects.map(r => {
    const rec2 = {
      x: r.x + avg_width/8,
      y: r.y + avg_height/8,
      width: avg_width*3/4,
      height: avg_height*3/4,
    };
    console.log(rec2);
    return clean.roi(rec2);
  });

  let results = [];
  let best = null;
  let best_score = 0;
  character_imgs.forEach(img => {
    /*let srcVec = new cv.MatVector();
    srcVec.push_back(bullet);
    let srcVec2 = new cv.MatVector();
    srcVec2.push_back(img);
    let accumulate = false;
    let channels = [0];
    let histSize = [256];
    let ranges = [0, 255];
    let hist = new cv.Mat();
    let hist2 = new cv.Mat();
    let mask = new cv.Mat();
    let color = new cv.Scalar(255, 255, 255);
    let scale = 2;
    // You can try more different parameters
    cv.calcHist(srcVec, channels, mask, hist, histSize, ranges, accumulate);
    cv.calcHist(srcVec2, channels, mask, hist2, histSize, ranges, accumulate);

    const score = cv.compareHist(hist, hist2, 3);
    if (score > best_score) {
      best = img;
      best_score = score;
    }*/
    let dst = new cv.Mat();
    let mask = new cv.Mat();
    const dsize = new cv.Size(img.cols*4/3, img.rows*4/3);
    cv.resize(bullet, bullet, dsize, 0, 0, cv.INTER_AREA);
    cv.matchTemplate(bullet, img, dst, cv.TM_CCOEFF, mask);
    let result = cv.minMaxLoc(dst, mask);
    if (result.maxVal > best_score) {
      best_score = result.maxVal;
      best = img;
    }
    results.push(result);
    //dst.delete(); mask.delete();
  });
  console.log(results);
  cv.imshow("imageCanvas", best);
  bullet.delete();

  //cv.imshow('imageCanvas', dst);

  // Clean
  src.delete(); itr.delete(); dst.delete(); contours.delete();
  hierarchy.delete(); hlines.delete(); vlines.delete();
  this.disabled = false;
};

document.getElementById('button').onclick = function() {
  this.href = document.getElementById("imageCanvas").toDataURL();
  this.download = "image.png";
};

function onOpenCvReady() {
  document.body.classList.remove("loading");
}
    </script>
    <script async src="opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
  </body>
</html>
